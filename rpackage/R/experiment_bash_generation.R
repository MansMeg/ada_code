#' Extract arguments from bash base
#'
#' @param return_name return the argument name
uppmax_bash_args <- function(return_name = TRUE){
  bcb <- bash_code_base()
  res <- gregexpr(pattern = "\\[[a-z_]*\\]",bcb)[[1]]
  out <- character(length(res))
  for(i in seq_along(res)){
    out[i] <- substr(bcb, res[i], res[i] - 1 + attr(res, "match.length")[i])
  }
  out <- out[-which(out %in% c("[model_config]", "[stan_arguments]", "[stan_control]"))]
  out <- unique(out)
  if(return_name){
    out <- gsub(out, pattern = "\\]", replacement = "")
    out <- gsub(out, pattern = "\\[", replacement = "")
  }
  out
}

#' Write a UPPMAX bash file from an argument list
#'
#' @param args a list with relevant arguments to put in [bash_code_base()]
#' @param model_config a list with model arguments
#' @param stan_arguments a list with stan arguments
#' @param stan_control a list with stan control arguments
#' @param directory path to output files
write_uppmax_bash <- function(args, directory, model_config, stan_arguments, stan_control){
  dir.create(directory, showWarnings = FALSE, recursive = TRUE)
  checkmate::assert_directory(directory)
  checkmate::assert_list(args)
  checkmate::assert_date(args$date_model_start, null.ok = FALSE)
  checkmate::assert_date(args$date_model_end, lower = args$date_model_start, null.ok = FALSE)

  # Add defaults
  args$date_model_start <- as.character(args$date_model_start)
  args$date_model_end <- as.character(args$date_model_end)
  if(is.null(args$date_polls_start)) args$date_polls_start <- args$date_model_start
  if(is.null(args$date_polls_end)) args$date_polls_end <- args$date_model_end
  if(is.null(args$date_known_state_end)) args$date_known_state_end <- args$date_model_end
  args$date_polls_start <- as.character(args$date_polls_start)
  args$date_polls_end <- as.character(args$date_polls_end)
  args$date_known_state_end <- as.character(args$date_known_state_end)
  if(is.null(args$job_id)) {
    args$job_id <- substr(digest::sha1(list(args, model_config, stan_arguments, stan_control)), 1, 8)
  }

  # Assert all arguments
  checkmate::assert_names(names(args), permutation.of = uppmax_bash_args(TRUE))
  all_args_are_characters <- all(unlist(lapply(args, class)) == "character")
  checkmate::assert_true(all_args_are_characters)
  checkmate::assert_choice(args$country, choices = c("germany", "sweden"))

  cb <- bash_code_base()
  for(i in seq_along(args)){
    cb <- gsub(cb, pattern = paste0("\\[", names(args)[i], "\\]"), replacement = args[i])
  }
  if(!is.null(model_config)){
    model_config <- model_config[!unlist(lapply(model_config, is.na))]
    suppressMessages(ada::model_config(args$stan_model, x = model_config))
    mc <- yaml::as.yaml(model_config)
    mc <- gsub(pattern = "\n", replacement = "\n    ", mc)
    mc <- paste0("hyper_parameters:\n    ",mc)
  } else {
    mc <- ""
  }
  if(!is.null(stan_arguments)){
    stan_arguments <- stan_arguments[!unlist(lapply(stan_arguments, is.na))]
    sa <- yaml::as.yaml(stan_arguments)
    sa <- gsub(pattern = "\n", replacement = "\n  ", sa)
  } else {
    stop("Stan arguments can't be NULL")
  }
  if(!is.null(stan_control)){
    stan_control <- stan_control[!unlist(lapply(stan_control, is.na))]
    sc <- yaml::as.yaml(stan_control)
    sc <- gsub(pattern = "\n", replacement = "\n    ", sc)
    sc <- paste0("control:\n    ", sc)
  } else {
    sc <- ""
  }

  cb <- gsub(cb, pattern = paste0("\\[model_config\\]"), replacement = mc)
  cb <- gsub(cb, pattern = paste0("\\[stan_arguments\\]"), replacement = sa)
  cb <- gsub(cb, pattern = paste0("\\[stan_control\\]"), replacement = sc)

  # Polish
  cb <- gsub(cb, pattern = paste0("\n[ ]*\n"), replacement = "\n\n")

  writeLines(cb, con = file.path(directory, paste0(args$job_id, ".sh")))
}


bash_code_base <- function(){
"#!/bin/bash
#SBATCH -A [sbatch_project]
#SBATCH --get-user-env
#SBATCH --time=[sbatch_time]
#SBATCH --cpus-per-task=[sbatch_cpus]

# NOTE: File generated by bash_code_base() and write_uppmax_bash()
# NOTE: Do not edit this file!

date

git rev-parse --short HEAD

export JOB_ID=\"[job_id]\"

module load R/3.6.1

# Setup yml config file
cat > $JOB_ID.yml <<EOF

job_id: \"$JOB_ID\"

model_arguments:
  stan_model: \"[stan_model]\"
  time_scale: \"week\"
  seed: [seed]
  dates_model:
    start: \"[date_model_start]\"
    end: \"[date_model_end]\"
  dates_polls:
    start: \"[date_polls_start]\"
    end: \"[date_polls_end]\"
  dates_known_state:
    end: \"[date_known_state_end]\"
  cache_dir: \"cache\"
  [model_config]
data:
  country: \"[country]\"
  parties: [parties]

stan_arguments:
  [stan_arguments][stan_control]

EOF

# Run model
Rscript bash_runs/run_model8d2.R $JOB_ID.yml

# Remove config
rm $JOB_ID.yml

date

"
}
